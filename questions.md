## NodeJS fundamentals

<details>
  <summary>Что такое NodeJS? На каком движке работает? Длячего используется библиотека libuv?</summary>
  libuv - библиотека на C, реализующая цикл событий Node.js и все асинхронные операции платформы.

Библиотека LibUV отвечает за две принципиально важные вещи:

- кроссплатформенные операции ввода-вывода — работа с файлами, работа с сетью(как работать с Windows, Linux);
- поддержка основного событийного цикла Node.JS.

Когда мы запускаем какой то скрипт, то он запускается в режиме цикла. Этот цикл чередует выполнение JavaScript, который обеспечивается виртуальной машиной V8, с ожиданием различных событий ввода-вывода, срабатывания таймеров, за которые так же отвечает библиотека LibUV.
И этот цикл будет продолжаться до тех пор, пока возможно появление каких то новых событий, ввода-вывода или таймеров которые нужно будет обработать.

Источник: [imnotgenius.com](http://imnotgenius.com/21-sobytijnyj-tsikl-biblioteka-libuv/)

</details>

<details>
  <summary>Что такое fs module? async/sync fc function</summary>
  Модуль fs(File system) предоставляет множество очень полезных функций для доступа к файловой системе и взаимодействия с ней.
  Одна особенность модуля fs заключается в том, что все методы по умолчанию асинхронны, но они также могут работать синхронно, добавив Sync.

```javascript
fs.rename("before.json", "after.json", (err) => {
  if (err) {
    return console.error(err);
  }

  //done
});
// <--------------------------
const fs = require("fs");

try {
  fs.renameSync("before.json", "after.json");
  //done
} catch (err) {
  console.error(err);
}
```

Ключевое отличие здесь в том, что выполнение вашего скрипта будет заблокировано во втором примере до тех пор, пока операция с файлом не завершится успешно.

Источник: [nodejs.dev](https://nodejs.dev/learn/the-nodejs-fs-module)

</details>

<details>
  <summary>Что такое Streams? Types of streams. Streams vs fs</summary>
  Потоки - одна из фундаментальных концепций, лежащих в основе приложений Node.js.
  Они позволяют эффективно обрабатывать чтение / запись файлов, сетевое взаимодействие или любой вид сквозного обмена информацией.
  Например, обычный способ, когда вы говорите программе прочитать файл, файл считывается в память от начала до конца, а затем вы его обрабатываете.
  Используя потоки, вы читаете его по частям, обрабатывая его содержимое, не сохраняя его в памяти.
  
  Потоки в основном предоставляют два основных преимущества по сравнению с другими методами обработки данных:

- Эффективность памяти: вам не нужно загружать большие объемы данных в память, прежде чем вы сможете их обработать;
- Экономия времени: для начала обработки данных требуется гораздо меньше времени, поскольку вы можете начать обработку, как только они у вас появятся, а не ждать, пока будет доступна вся полезная нагрузка данных.

```javascript
const http = require("http");
const fs = require("fs");

const server = http.createServer(function (req, res) {
  fs.readFile(__dirname + "/data.txt", (err, data) => {
    res.end(data);
  });
  // vs
  const stream = fs.createReadStream(__dirname + "/data.txt");
  stream.pipe(res);
});
server.listen(3000);
```

Вместо того, чтобы ждать, пока файл будет полностью прочитан, мы начинаем его потоковую передачу HTTP-клиенту, как только у нас есть фрагмент данных, готовый к отправке.
Источник: [nodejs.dev](https://nodejs.dev/learn/nodejs-streams)

</details>

<details>
  <summary>Что такое Event Loop? Phases</summary>
  Код JavaScript для Node.js выполняется в одном потоке. Одновременно происходит только одно событие.

Обзор фаз:

- таймеры: в этой фазе выполняются коллбэки, запланированные setTimeout() и setInterval();
- I/O коллбэки: выполняются почти все коллбэки, за исключением событий close, таймеров и setImmediate();
- ожидание, подготовка: используется только для внутренних целей;
- опрос: получение новых событий ввода/вывода. Node.js может блокироваться на этом этапе;
- проверка: коллбэки, вызванные setImmediate(), вызываются на этом этапе;
- коллбэки события close: например, socket.on('close', ...);
  Между каждой итерацией цикла событий Node.js проверяет, ожидается ли завершение каких-либо асинхронных операций ввода/вывода или таймеров, и завершает работу, если их нет.

![](https://habrastorage.org/r/w780/getpro/habr/post_images/0fd/b3b/2e9/0fdb3b2e986359c1aa073bfc34b5e36f.png)

Источник: [medium.com](https://medium.com/devschacht/event-loop-timers-and-nexttick-18579cd122e0)

</details>

<details>
  <summary>EventEmitter и утечки памяти</summary>
  «EventEmitter» представляет собой основной объект реализующий работу с событиями в Node.JS. Большое количество других встроенных объектов, которые генерируют события в Node.JS, ему наследуют.

![image](https://user-images.githubusercontent.com/62482805/138591485-953099a8-e609-41fd-8d15-09f8d4ecb1b3.png)

![image](https://user-images.githubusercontent.com/62482805/138592107-d41b2aeb-714d-4b55-83c4-01c864709b2d.png)

Источник: [medium.com](https://medium.com/devschacht/event-loop-timers-and-nexttick-18579cd122e0)

</details>

## Clean Code

<details>
  <summary>Linters</summary>
</details>

<details>
  <summary>Git Hooks. Husky</summary>
  pre-commit, pre-push
</details>

<details>
  <summary>How to keep clean code? How to enforce clean code on a project?</summary>

1. Придерживаться соглашения нэйминга переменных:

- Для имен классов используйте UpperCamelCase с заглавной первой буквой.
- При именовании функций использовать CamelCase
- Для констант и переменных с более чем одним именем в объявлении использовать подчеркивание для разделения имен.

2. Разделяйте свои функции:

- Простой способ упорядочить ваш код - создать функцию для каждой отдельной задачи. Если функция делает больше, чем следует из ее названия, вам следует подумать о разделении функциональности и создании другой функции.
- Использование меньших функциональных блоков делает ваш код аккуратным. Кроме того, у вас может быть функция maininit (), которая хранит структуру приложения. Это упрощает повторное использование функций без дублирования кода.

3. Правильное комментирование:

- Комментарии проясняют сложные сегменты и объясняют высокоуровневые механизмы в вашем коде. Они описывают функциональность конкретного блока кода, тем самым давая другим программистам возможность лучше понять ваш код.
- Комментируя, воздержитесь от ненужных комментариев, которые повторяют тривиальные вещи.

4. Деструктуризация:

- позволяет разбивать сложные структуры данных, такие как объекты или массивы, на более простые части. Он обеспечивает удобный способ доступа к элементам массива и свойствам объекта.

5. Do Not Repeat Yourself
6. Использовать prettier
7. Используйте осмысленные имена переменных.
8. Порядок импорта модулей

Источник: [blog.logrocket.com](https://blog.logrocket.com/12-tips-for-writing-clean-and-scalable-javascript-3ffe30abfe20/)

</details>

## HTTP

<details>
  <summary>Что такое HTTP? HTTP методы. PUT vs POST</summary>
  HTTP — это просто название самого популярного протокола для общения в сети, и браузеры в основном выбирают HTTP при общении с серверами. HTTP-обмен подразумевает, что клиент (наш браузер) отправляет запрос, а сервер присылает ответ.

Работа браузера в основном состоит из:

- Разрешение DNS
- HTTP-обмен
- Рендеринг
- Сброс и повтор

Методы: GET, POST, PUT, PATCH, DELETE.

  <table>
    <thead>
      <tr>
        <th>
          <strong>PUT</strong>
        </th>
        <th>
          <strong>POST</strong>
        </th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>RFC-2616 четко упоминает, что метод PUT запрашивает прикрепленный объект (в теле запроса), который должен быть сохранен на сервере, на котором размещен предоставленный Request-URI.<br><br>Если Request-URI относится к уже существующему ресурсу - произойдет операция обновления, в противном случае должна произойти операция создания, если Request-URI является допустимым URI ресурса (при условии, что клиенту разрешено определять идентификатор ресурса)..<pre>PUT /questions/{question-id}</pre></td>
        <td>>Метод POST используется для запроса, чтобы исходный сервер принял объект, прикрепленный в запросе, в качестве нового подчиненного ресурса, идентифицированного Request-URI в строке запроса.<br><br>По сути, это означает, что URI запроса POST должен иметь URI коллекции.<pre>POST /questions</pre></td>
      </tr>
      <tr>
        <td>Метод PUT идемпотентен. Поэтому, если мы повторим запрос несколько раз, это должно быть эквивалентно вызову одного запроса.</td>
        <td >POST НЕ идемпотентен. Итак, если мы повторим запрос N раз, у нас будет N ресурсов с N разными URI, созданными на сервере.</td>
      </tr>
      <tr>
        <td>Используйте PUT, когда мы хотим изменить отдельный ресурс, который уже является частью коллекции ресурсов.<br><br>PUT полностью заменяет ресурс. Используйте PATCH, если запрос обновляет часть ресурса.</td>
        <td>Используйте POST, если вы хотите добавить дочерний ресурс в коллекцию ресурсов.</td>
      </tr>
      <tr>
        <td>Хотя PUT идемпотентен, мы не должны кэшировать его ответ.</td>
        <td>Ответы на этот метод не кэшируются, если ответ не включает соответствующие поля заголовка Cache-Control или Expires.<br><br>Однако ответ 303 (см. Прочее) может использоваться для указания пользовательскому агенту получить кэшируемый ресурс.</td>
      </tr>
      <tr>
        <td>Как правило, на практике используйте PUT для операций UPDATE.</td>
        <td>Всегда используйте POST для операций CREATE.</td>
      </tr>
    </tbody>
  </table>
</details>

<details>
  <summary>Что такое WS protocol? Цель использования? Как происходит процесс установки соединения по WS? Альтернативы WS?</summary>
  WebSocket - постоянное соединение между клиентом и сервером, пользуясь которыми клиент и сервер могут отправлять данные друг другу в любое время.
  Один из наиболее часто используемых приёмов для создании иллюзии того, что сервер самостоятельно отправляет данные клиенту, называется «длинный опрос» (long polling). С использованием этой технологии клиент открывает HTTP-соединение с сервером, который держит его открытым до тех пор, пока не будет отправлен ответ. В результате, когда у сервера появляются данные для клиента, он их ему отправляет.
  У таких технологий одна и та же проблема: дополнительная нагрузка на систему, которую создаёт использование HTTP, что делает всё это неподходящим для организации работы приложений, где требуется высокая скорость отклика. 
</details>

## Express

<details>
  <summary>Что такое Express? Для какой цели он используется? В чём преимущество использования Express над нативными модулями nodejs?</summary>

  Express - самый популярный веб-фреймворк для Node.
  Он предоставляет следующие механизмы:
  - Написание обработчиков для запросов с различными HTTP-методами в разных URL-адресах (маршрутах).
  - Интеграцию с механизмами рендеринга «view», для генерации ответов, вставляя данные в шаблоны.
  - Установка общих параметров веб-приложения, такие как порт для подключения, и расположение шаблонов, которые используются для отображения ответа.
  - «middlewares» для дополнительной обработки запроса в любой момент в конвейере обработки запросов.
</details>

<details>
  <summary>Express routing. Как происходит сопоставление path и зарегестрированного в приложении обработчика?</summary>

  Route - это часть кода Express, которая связывает команду HTTP (GET, POST, PUT, DELETE и т. Д.), Путь / шаблон URL-адреса и функцию, которая вызывается для обработки этого шаблона.
  Ниже приводятся примеры путей маршрутов на основе строк.

  Данный путь маршрута сопоставляет запросы с корневым маршрутом, /.
  ```javascript
  app.get('/', function (req, res) {
    res.send('root');
  });
  ```
  Примеры путей маршрутов на основе регулярных выражений.

  Данный путь маршрута сопоставляет любой элемент с “a” в имени маршрута.
  ```javascript
  app.get(/a/, function(req, res) {
    res.send('/a/');
  });
  ```
  Источник: [expressjs.com](https://expressjs.com/ru/guide/routing.html)
</details>

<details>
  <summary>Что такое middleware?</summary>

  Функции промежуточной обработки (middleware) - это функции, имеющие доступ к объекту запроса (req), объекту ответа (res) и к следующей функции промежуточной обработки в цикле “запрос-ответ” приложения. Следующая функция промежуточной обработки, как правило, обозначается переменной next.
  ![image](https://user-images.githubusercontent.com/62482805/138703995-3f6a48b8-fb50-451e-bfc2-39a0ce76ceee.png)

  Источник: [expressjs.com](https://expressjs.com/ru/guide/writing-middleware.html#:~:text=%D0%9E%D0%B1%D0%B7%D0%BE%D1%80,%D0%BA%D0%B0%D0%BA%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE%2C%20%D0%BE%D0%B1%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82%D1%81%D1%8F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9%20next%20.)
</details>

<details>
  <summary>Как происходит обработка ошибок в express? Как создать кастомный обработчик ошибок?</summary>

  Можно обработывать синхронные и асинхронные ошибки.

  Синхронные:
  ```javascript
  app.post('/testing', (req, res) => {
    throw new Error('Something broke! ')
  })
  ```
  Такие ошибки можно перехватить с помощью обработчика ошибок Express.
  Вот что делает стандартный обработчик ошибок Express:
  - Устанавливает код состояния HTTP-ответа в значение 500.
  - Отправляет сущности, выполнившей запрос, текстовый ответ.
  - Логирует текстовый ответ в консоль.

  Для обработки асинхронных ошибок нужно отправить ошибку обработчику ошибок Express через аргумент next:
  ```javascript
  app.post('/testing', async (req, res, next) => {
    return next(new Error('Something broke again! '))
  })
  ```
  Обработчики ошибок Express принимают 4 аргумента:
  - error
  - req
  - res
  - next

  Размещать их нужно после промежуточных обработчиков и маршрутов.
  Если создать собственный обработчик ошибок, то Express прекратит использование стандартного обработчика. Для того чтобы обработать ошибку, нужно сформировать ответ для фронтенд-приложения, которое обратилось к конечной точке, в которой возникла ошибка. Это означает, что нужно выполнить следующие действия:
  - Сформировать и отправить подходящий код состояния ответа.
  - Сформировать и отправить подходящий ответ.

  ```javascript
  app.use((error, req, res, next) => {
    // Ошибка, выдаваемая в ответ на неправильно сформированный запрос
    res.status(400)
    res.json(/* ... */)
  })  
  ```
  Источник: [habr.com](https://habr.com/ru/company/ruvds/blog/476290/)
</details>

<details>
  <summary>Валидация. Для чего она нужна? На каком этапе должна проходить валидация? Как обрабатывать ошибки валидации?</summary>
</details>

<details>
  <summary>Трехуровневая архитектура. Из каких слоёв она состоит? Какие задачи решает каждый слой?</summary>

  Трехуровневая архитектура - это архитектура веб-приложений, которая широко используется во всем мире. В основном он содержит 3 уровня: клиент, сервер и база данных.

  Это архитектура приложения основана на типичной модели MVC. 
  
  Клиентский уровень (View) будет написан на Javascript, HTML и CSS с использованием ReactJS в качестве фреймворка. Этот уровень архитектуры - это то, с чем пользователь будет взаимодействовать, чтобы получить доступ к функциям нашего приложения.

  Уровень бизнес-логики (Controller) например написан с использованием NodeJs и ExpressJS, и этот уровень представляет собой сервер приложений, который будет действовать как мост для связи для уровня клиента и уровня базы данных. Этот уровень будет обслуживать HTML-страницы на устройстве пользователя и принимать HTTP-запросы от пользователя с соответствующим ответом.

  Уровнь базы данных (Model). Здесь мы хранятся все важные данные, необходимые нашему приложению для работы.

  Источник: [ichi.pro](https://ichi.pro/ru/polnoe-rukovodstvo-po-sozdaniu-horoso-strukturirovannoj-trehurovnevoj-arhitektury-stek-mern-es6-222181300500485)

</details>

<details>
  <summary>Что за Dependency injection паттерн? Для чего служит DI патерн и как его использовать в Express?</summary>

  В разработке программного обеспечения, внедрение зависимостей это такая техника, где посредством одного объекта (или статического метода) предоставляются зависимости другого объекта. Зависимость — это объект, который может быть использован (как сервис).

  Существует три основных типа внедрения зависимостей:
  - constructor injection: все зависимости передаются через конструктор класса.
  - setter injection: разработчик добавляет setter-метод, с помощью которого инжектор внедряет зависимость
  - interface injection: зависимость предоставляет инжектору метод, с помощью которого инжектор передаст зависимость. Разработчики должны реализовать интерфейс, предоставляющий setter-метод, который принимает зависимости.

  Инверсия управления — концепция, лежащая в основе внедрения зависимости
  Это означает, что класс не должен конфигурировать свои зависимости статистически, а должен быть сконфигурирован другим классом извне.

  Преимущества использования внедрения зависимостей:
  - Помогает в модульном тестировании
  - Количество шаблонного кода сокращается, поскольку инициализация зависимостей выполняется компонентом инжектора;
  - Расширение приложения становится еще проще;
  - Помогает уменьшить связность кода, что важно при разработке приложений.

  Источник: [medium.com](https://xufocoder.medium.com/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-de1367295ba8)
</details>

## Relational DataBase (RB)

<details>
  <summary>Для чего используют RD?</summary>

  Реляционная база данных – это набор данных с предопределенными связями между ними. 
  Эти данные организованны в виде набора таблиц, каждая строка содержит запись с уникальным идентификатором, известным как ключ, и каждый столбец содержит атрибуты данных. В таблицах хранится информация об объектах, представленных в базе данных.

  К основным преимуществам реляционных баз данных можно отнести следующее:
  - Категоризация данных. Администраторы баз данных могут легко классифицировать и хранить данные в реляционной базе данных, которые затем можно запрашивать и фильтровать для извлечения информации для отчетов. Реляционные базы данных также легко расширяются и не зависят от физической организации. После создания исходной базы данных можно добавить новую категорию данных без изменения существующих приложений.
  - Точность. Данные хранятся только один раз, что исключает дедупликацию данных в процедурах хранения.
  - Сотрудничество. Несколько пользователей могут получить доступ к одной и той же базе данных.
  - Безопасность. Прямой доступ к данным в таблицах в РСУБД может быть ограничен определенными пользователями.

  Cloud-based relational databases - Amazon Relational Database Service, Google Cloud SQL, IBM DB2 on Cloud, SQL Azure and Oracle Cloud.

  Источник: [techtarget.com](https://searchdatamanagement.techtarget.com/definition/relational-database)
</details>

<details>
  <summary>Что такое RDBMS и какая цель использования?</summary>
  
  RDBMS (Relational Database Management System) – это система для управления базами данных (далее – БД), базирующаяся на реляционной модели.
  
  Таблица 

  В RDBMS данные хранятся в объектах, которые называются таблицами. Таблица – это набор связанных по смыслу данных, состоящий из столбцов и рядов.

  Поле, Запись, Колонка, NULL.

  Источник: [proselyte.net](https://proselyte.net/tutorials/sql/rdbms-basic-concepts/)
</details>

<details>
  <summary>Что такое индекс и для чего он используется? Как задать индекс?</summary>

  Констрейнт INDEX используется для того, чтобы крайне быстро добавлять и получать данные из таблицы. 

  Правильное использование данного элемента способно крайне повысить производительность при работе с большими базами данных (далее – БД).

  Источник: [proselyte.net](https://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-index/)
</details>

<details>
  <summary>Отошение в rd. Many-to-many и промежуточная таблица. Для чего необходима</summary>
  Источник: [proselyte.net](https://proselyte.net/tutorials/sql/rdbms-basic-concepts/constraint-index/)
</details>

